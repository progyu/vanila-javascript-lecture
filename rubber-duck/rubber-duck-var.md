# Morning rubber-duck(variable)

- **변수**

  - **하나의 값**을 저장할 수 있는 **메모리 공간에 붙인 이름** 또는 메모리 공간 자체

  - **값을 재사용** 할 수 있도록 메모리 공간을 **식별할 수 있는 이름**을 붙인 것 

    

- **파싱**

  - 텍스트로 되어 있는 소스코드를 브라우저가 이해하기 위해 **해석**한다.



- **변수 선언**
  - 선언 단계
    - 변수명(식별자)을 **등록**하여 자바스크립트 엔진에 **변수의 존재를 알려 관리**하도록 하는 것.
  - 초기화 단계
    - 값을 저장하기 위한 **메모리 공간을 확보**하고 암묵적으로 **undefined를 할당**한다.



- **할당**  
  - 새로운 메모리 공간에 값을 저장하고 변수가 그 공간을 가리키는 것.



- **식별자** 
  - 어떤 값을 구별하여 식별해낼 수 있는 고유한 이름



- **정의** : 식별자의 정체를 알리는 것



- **값**
  - **더 이상 평가할 수 없는 하나의 표현식**
  - 값은 변수에 할당할 수 있다.



- **평가**
  - 표현식을 해석하여 하나의 값을 만드는 과정



- **데이터 타입이 필요한 이유**
  - 값을 **저장할 때** 확보해야 하는 **메모리 공간의 크기**를 결정하기 위해
  - 값을 **참조할 때** 한번에 읽어 들여야 할 **메모리 공간의 크기**를 결정하기 위해
  - 메모리에서  읽어 들인 **2진수를 어떻게 해석**할 지를 결정하기 위해 



- **표현식**
  - 표현식은 평가되어 하나의 값을 만든다.
  - **하나의 값으로 평가될 수 있는 문**
  - 값을 만드는 방법



- **문**
  - 하나 이상의 표현식과 키워드의 조합, 명령



   - **표현식인 문**  
           - 값으로 평가될 수 있는 문
           - 변수에 할당할 수 있다. 
   - **표현식이 아닌 문**            
           - 값으로 평가될 수 없는 문
           -  변수에 할당할 수 없다



- **제어문**

  - 주어진 조건에 따라 코드 블록을 실행하거나 반복 실행한다.

  

- **조건문**

  - 조건에 따라 실행 여부를 결정
  - **조건식은 불리언 값으로 평가될 수 있는 표현식**

  

- **반복문**

  - 조건식이 **거짓으로 판별 될 때까지** 코드 블록을 반복 실행
  - 그 후 조건식을 검사하여 여전히 참인 경우 코드 블록을 실행



- **리터럴**

  - **소스 코드 안에서 직접 만들어 낸 고정된 값 자체**
  - 자바스크립트 엔진에 의해 해석되어 값으로 평가된다.
  - **값의 생성을 자바스크립트 엔진에게 명령하는 것**
  - 그 자체로 표현식이며 표현식의 일부로서 다른 값을 생성하는데 사용되기도 한다.

  

- **리터럴 표기법**

  - 리터럴을 기술하는 방식
  - **값을 생성하는 가장 기본적인 방법**
  - 자바스크립트 엔진에 의해 해석되어 값으로 평가된다.



- **변수 호이스팅**
  - 변수 선언(선언단계, 초기화 단계)이 **런타임 이전**에 먼저 실행되어 마치 변수 선언문이 **스코프의 선두**로 끌어 올려진 것처럼 동작하는 것.
  - 스코프 단위로 동작.



- **동적 타이핑**
  - 자바스크립트 변수는 선언이 아닌 **할당에 의해 타입이 결정**
  - 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다.




- **명시적 / 암묵적 타입변환**
  - 명시적 타입변환 
    - **개발자가 의도적으로 타입을 변환하는 것.**
    - 타입을 변경하겠다는 개발자의 의지가 코드에 명백히 드러난다.
  - 암묵적 타입변환 
    - **자바스크립트 엔진에 의해 타입이 변환되는 것.**
    - `+`연산자 : 피연산자 중 하나 이상이 문자열이면 문자열 연결 연산자로 동작
    - `+`    ' '
    - 앞에 `+`연산자를 붙이면 숫자타입으로 변환
      - 빈 객체({}), undefined는 `NaN`
      - 빈 문자열(''), 빈 배열([]), null, false 은 `0`
    - Falsy
      - false
      - undefined
      - null
      - 0, -0
      - NaN
      - '' (빈문자열)



- **단축평가(&&, ||)**
  - **논리 연산의 결과를 결정한 피연산자를 반환한다.**
  - &&(and, 논리곱 연산자) : 두개의 피연산자가 **모두 `true`로 평가될 때** true를 반환한다.
  - ||(or, 논리합 연산자) : 두개의 피연산자 중 **하나만 `true`로 평가되면** true를 반환한다.

```javascript
'cat' && 'dog'    // 'dog'
false && 'cat'    // false
'dog' && false    // false
   '' && false    // ''

'cat' || 'dog'    // 'cat'
false || 'dog'    // 'dog'
'cat' || false    // 'cat'
   '' || false    // false
```



- **함수란 무엇인가?**

  - **일련의 과정을 문들로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것**
  - **함수는 객체이다**
  - 코드의 재사용이라는 측면에서 매우 유용
  - 유지보수의 편의성과 코드의 신뢰성을 높이는 효과가 있다.
  - **함수명이 아닌 함수 객체를 가리키는 변수로 호출**

  

- **원시타입과 참조타입**

  - 원시 타입
    - 변수에 **원시 값**을 저장
    - **immutable value(변경 불가능한 값)**
    - 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 **원시 값**이 **복사**되어 전달 --> **값에 의한 전달(Pass by value)**
    - 재할당 이외의 방법으로는 값을 변경할 수 없다.
  - 참조 타입(객체 타입)
    - 변수에 **참조 값(생성된 객체가 저장된 메모리 공간의 주소)**을 저장
    - **mutable value(변경 가능한 값)**
    - 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 **참조 값**이 **복사**되어 전달 --> **참조에 의한 전달(Pass by reference)**
    - 재할당 이외의 방법으로도 값을 변경할 수 있다.



- **함수 선언문 과 함수 표현식의 차이?**

  - 함수 선언문
    - **선언과 동시에 할당이 이루어진다.**
    - 함수 호이스팅
      - **선언단계와 초기화 단계 , 그리고 할당 단계까지 동시에 진행**

     ```javascript
    foo(); // 10
    
    function foo () {
    	console.log(10);
    };
     ```

    - 함수명을 생략할 수 없다.

  - 함수 표현식
    - 선언만이 런타임 전에 이루어진다.
    - 변수 호이스팅과 유사
      - `var` 키워드 : 선언 단계와 초기화 단계 진행
      - `let`, `const` 키워드 : 선언 단계만 진행

    ```javascript
    console.log(add(2, 3)); // add is not a function
    
    var add = function (a, b) {
        return a + b;
    }
    
    
    console.log(add(2, 3));// add is not defined
    
    const add = function (a, b) {
        return a + b;
    }
    ```

    - 함수명을 생략할 수 있다.



- **콜백은 무엇이고 어떻게 활용되는가?**
  - **다른 함수에 인수로 전달된 함수**
  - 자바스립트에서 함수는 일급 객체이므로, 함수를 인수로 전달 할 수 있다.
  - **콜백함수는 콜백함수를 인수로 전달 받은 함수가 호출 시점을 결정**
  - 함수에 전달되어 **헬퍼 함수의 역할**을 한다.
  - **함수 외부에서 인수로 주입하기 때문에 자유롭게 교체할 수 있다는 장점이 있다.**
  - 비동기 처리를 위해 사용하는 일반적인 패턴으로 주로 **이벤트 처리**나 **Ajax** 통신에 사용
  - **고차함수**에서도 사용하는 패턴으로 사용 빈도가 높고 중요한 패턴이다.



- **자바스크립트에서 객체란 무엇인가?**

  - **키**(key)와 **값**(value)으로 구성된 **프로퍼티**(Property)들의 집합, 변경 가능한 값(immutable value)이다.
  - 동적 추가 삭제 --> 메모리 공간의 크기를 사전에 정해 둘 수 없다.
  - 객체의 단점 --> **여러 개의 식별자가 하나의 객체를 공유할 수 있다**

  

- **자바스크립트 객체 프로퍼티 여러 접근 방법**

  - 마침표 표기법 : person.name;
  - 대괄호 표기법 : person.['name'];
    - 반드시 대괄호 내부를 따옴표로 감싸야 한다.
    - 프로퍼티 키가 식별자 네이밍 규칙을 준수하지 않는 이름이면 반드시 대괄호 표기법을 사용해야 한다.



- **스코프란?**
  - 변수는 자신이 **선언된 위치**에 의해 자신이 **유효한 범위**, 즉 다른 코드가 변수 자신을 **참조할 수 있는 범위**가 결정된다.
  - 자바스크립트 엔진이 참조할 **변수를 검색할 때 사용하는 규칙**
  - 변수명(식별자)의 충돌을 방지하여 같은 이름의 변수를 사용할 수 있도록 한다.
  - 지역 변수는 자신의 지역 스코프와 하위 지역 스코프에서 유효



- **스코프 체인**
  - 스코프가 계층적으로 연결된 것
  - **스코프는 함수의 중첩에 의해 계층적 구조를 갖는다**
  - 변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 **상위 스코프 방향으로 이동**하며 선언된 변수를 검색한다.





- **var 키워드로 선언한 변수의 문제점**
  - **같은 스코프 내에서 중복 선언이 허용된다.** 
  - 블록 레벨 스코프를 지원하지 않는다.(함수 레벨 스코프)
  - 변수 호이스팅



- **전역 변수의 문제점**

  - 암묵적 결합
    - **모든 코드가 전역 변수를 참조하고 변경할 수 있다.**
    - 코드의 가독성이 나빠지고 의도치 않게 상태가 변경될 수 있는 위험성도 높아진다.
  - 긴 생명 주기
    -  전역 변수의 상태를 변경할 수 있는 시간이 길다.
    - 메모리 리소스를 오랜 기간 소비한다.
  - 스코프 체인 상에서 종점에 존재
    - 변수를 검색할 때 전역 변수가 가장 마지막에 검색 된다.
    - 즉, 전역 변수의 검색 속도가 가장 느리다.
  - 네임 스페이스 오염
    - **파일이 분리되어 있다하여도 하나의 전역 스코프를 공유한다.**
    - 다른 파일 내에서 동일한 이름으로 명명된 변수나 함수가 같은 스코프 내에 존재할 경우 예상치 못한 결과를 가져올 수 있다.

    

- **var, let , const 키워드의 차이점**

  - `var` 키워드는 선언과 초기화(undefined가 변수에 할당) 가 동시에 이루어진다. (런타임 **전**) --> 변수 호이스팅
  - `let` 과 `const` 키워드는 런타임 전 선언되고 런타임에 초기화 된다. --> 마치 변수 호이스팅이 일어나지 않는 것처럼 보인다.

  ```javascript
  console.log(varTest); // undefined
  
  var varTest = 'test1'; 
  
  console.log(letTest); // Uncaught ReferenceError: Cannot access 'letTest' before initialization
  
  let letTest = 'test2'; 
  
  console.log(constTest); // Uncaught ReferenceError: Cannot access 'letTest' before initialization
  
  const constTest = 'test3'; 
  ```

  - `var` 키워드와 `let` 키워드는 재할당이 가능하지만 `const` 키워드는 **재할당이 불가능**하다. 

  ```javascript
  const age = 20;
  
  age = 30; // Uncaught TypeError: Assignment to constant variable.
  ```

  

  - `const` 키워드는 반드시 선언과 할당을 **하나의 문**에 하여야 한다.

  ```javascript
  const name; // Uncaught SyntaxError: Missing initializer in const declaration
  
  const name = 'Lee'; // o
  ```

  



- **렉시컬 스코프**(정적 스코프)
  - 함수를 어디서 **정의**했는지에 따라 **상위스코프**를 결정하는 것. 



