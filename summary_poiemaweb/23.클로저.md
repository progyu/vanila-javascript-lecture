## 렉시컬 스코프

스코프의 실체는 실행 컨텍스트의 렉시컬 환경이다. 이 렉시컬 환경은 자신의 **“외부 렉시컬 환경에 대한 참조(Outer Lexical Environment Reference)”를 통해 상위 렉시컬 환경과 연결**된다. 이것이 바로 **스코프 체인**이다.

따라서 "함수가 상위 스코프를 결정한다"는 것은 "**렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 저장할 참조 값을 결정**한다"는 것과 같다.

모든 함수는 **함수 정의가 평가되어 함수 객체를 생성**할 때, **현재 실행중인 실행 컨텍스트의 렉시컬 환경**을 **함수 객체의 내부 슬롯** `[[Environment]]`에 저장한다.

​              

```javascript
const x = 1;

function foo() {
  const x = 10;

  // 상위 스코프는 함수 정의 위치에 따라 결정된다.
  // 함수 호출 위치와 상위 스코프는 아무런 관계가 없다.
  bar();
}

// 함수 bar는 자신이 정의되었을 당시의 상위 스코프, 즉 전역 렉시컬 환경을 기억한다.
function bar() {
  console.log(x);
}

foo(); // ?
bar(); // ?

// foo 함수와 bar 함수의 내부 슬롯 [[Environment]]에는 함수 정의가 평가된 시점, 즉, 전역 코드 평가 시점에 실행중인 실행 컨텍스트의 렉시컬 환경인 전역 렉시컬 환경의 참조가 저장된다. 그 후 함수 코드가 평가되며 함수 실행 컨텍스트가 생성되고 렉시컬 환경
```

**foo 함수와 bar 함수의 내부 슬롯** `[[Environment]]`에는 함수 정의가 평가된 시점, 즉, 전역 코드 평가 시점에 실행중인 실행 컨텍스트의 렉시컬 환경인 **전역 렉시컬 환경의 참조가 저장**된다. 그 후 함수 코드가 평가되며 **함수 렉시컬 환경의 컴포넌트인 외부 렉시컬 환경의 참조**에는 **내부 슬롯** `[[Environment]]`에 저장된 **전역 렉시컬 환경의 참조가 할당**된다.

**즉,  함수의 내부 슬롯  `[[Environment]]`에 저장된 참조 ===  함수 렉시컬 환경의 컴포넌트인 외부 렉시컬 환경의 참조에 할당된 참조 ** => 함수의 상위 스코프



## 클로저와 렉시컬 환경

```javascript
const x = 1;

// ①
function outer() {
  const x = 10;
  const inner = function () { console.log(x); }; // ②
  return inner;
}

/**
 *  함수 outer를 호출하면 중첩 함수 inner를 반환한다.
 *  그리고 함수 outer의 실행 컨텍스트는 실행 컨텍스트 스택에서 pop된다.
 */
const innerFunc = outer(); // ③
innerFunc(); // ④ 10
```



**위 예제 코드처럼 외부 함수보다 중첩 함수가 더 오래 유지 되는 경우**, 외부 함수 밖에서 중첩 함수를 호출하더라도 외부 함수의 지역 변수에 접근할 수 있는데 이러한 함수를 **클로저**(Closure)라고 부른다.

**클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다.** => "그 함수가 선언된 렉시컬 환경" 이란 함수가 정의된 위치의 스코프, 즉 **상위 스코프를 의미**한다.

자바스크립트의 모든 함수는 자신의 상위 스코프를 기억 한다. 즉, 언제나 자신이 기억하는 상위 스코프의 변수를 참조할 수 있으며 상위 스코프의 변수값을 변경할 수도 있다.

outer 함수의 실행이 종료하면 inner 함수를 반환하면서 outer 함수의 생명 주기는 종료한다. 즉, outer 함수의 실행 컨텍스트가 실행 컨텍스트 스택에서 제거된다. 하지만, outer 함수의 렉시컬 환경까지 소멸하는 것은 아니다. **outer 함수의 렉시컬 환경은 inner 함수의 `[[Environment]]` 내부 슬롯에 의해 참조되고 있으므로 가비지 컬렉션의 대상이 되지 않기 때문이다.**



### 클로저라고 할 수 없는 경우

**이론적으로 자바스크립트의 모든 함수는 상위 스코프를 기억하므로 모든 함수는 클로저이다. 하지만 일반적으로 모든 함수를 클로저라고 하지는 않는다.**

1. **중첩함수가 상위 스코프의 식별자를 참조하지 않는 경우**에는 클로저라고 할 수 없다. 이런 경우에 모던 브라우저는 상위 스코프를 기억하지 않는다. 참조하지도 않는 식별자를 기억하는 것은 메모리 낭비이기 때문이다.
2. **중첩함수가  외부 함수와 생명 주기가 같거나 더 짧은 경우** => 호출 위치 상관 없이 상위 스코프를 **기억**하고 참조할 수 있다는 클로저로써의 본질에 부합하지 않는다.

이와 같이 클로저는 중첩 함수가 상위 스코프의 식별자를 참조하고 있고 중첩 함수가 외부 함수보다 더 오래 유지되는 경우에 한정하는 것이 일반적이다.

클로저에 의해 참조되는 상위 스코프의 변수를 **자유변수**(Free variable)라고 부른다.

클로저라는 이름은 자유 변수에 함수가 닫혀있다(closed)라는 의미이다.

좀 더 알기 쉽게 의역하자면 **"자유 변수와 묶여있는 함수"를 클로저**라 한다.



### 클로저의 활용

클로저는 자바스크립트의 강력한 기능으로 적극적으로 사용해야 한다.

클로저는 상태를 안전하게 유지하기 위해 사용한다. 즉, 상태가 의도치 않게 변경되지 않도록 안전하게 은닉(Information hiding)하고 이전 상태를 기억하고 상태가 변경되면 최신 상태를 유지한다.