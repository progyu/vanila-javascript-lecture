# 문서 객체 모델(Document Object Model)



## DOM

텍스트 파일로 만들어져 있는 웹 문서를 브라우저에 렌더링하려면 웹 문서를 브라우저가 이해할 수 있는 구조로 메모리에 올려야 한다. 브라우저의 렌더링 엔진은 웹 문서를 로드한 후, **파싱하여 웹 문서를 브라우저가 이해할 수 있는 구조로 구성하여 메모리에 적재하는데 이를 DOM이라 한다.** 

**모든 요소**와 **요소의 어트리뷰트**, **텍스트**를 각각의 **객체**로 만들고 이들 객체를 **부자 관계**로 표현할 수 있는 **트리 구조**로 구성한 것이 **DOM**이다.

이 DOM은 자바스크립트를 통해 동적으로 변경할 수 있으며 DOM은 렌더링에 반영된다. 이러한 웹 문서의 **동적 변경을 위해** DOM은 프로그래밍 언어가 자신에 **접근하고 수정할 수 있는 방법을 제공**하는데 일반적으로 **프로퍼티와 메소드를 갖는 자바스크립트 객체**로 제공된다. 이를 **DOM API**(Application Programming Interface)라고 부른다.



### DOM의 두 가지 기능

> **HTML 문서에 대한 모델 구성**
>
> 브라우저는 HTML 문서를 로드한 후 해당 문서에 대한 모델을 메모리에 생성한다. 이 때 모델은 객체의 트리로 구성되는데 이것을 DOM tree라 한다.

> **HTML 문서 내의 각 요소에 접근 / 수정**
>
> DOM은 모델 내의 각 객체에 접근하고 수정할 수 있는 프로퍼티와 메소드를 제공한다.  DOM이 수정되면 브라우저를 통해 사용자가 보게 될 내용 또한 변경된다.



## DOM tree

DOM tree는 브라우저가 HTML 문서를 로드한 후 파싱하여 생성하는 **모델을 의미**한다. 객체의 **트리로 구조화**되어 있기 때문에 DOM tree라 부른다.

DOM에서 모든 요소, 어트리뷰트, 텍스트는 하나의 객체이며 Document 객체의 자식이다. **요소의 중첩관계는 객체의 트리로 구조화하여 부자관계를 표현한다**.



### DOM tree 노드 종류

**문서 노드(Document Node)**

트리의 최상위에 존재하며 각각 요소, 어트리뷰트, 텍스트 노드에 접근하려면 문서 노드를 통해야 한다. **즉, DOM tree에 접근하기 위한 시작점(entry point)이다.**

**요소 노드(Element Node)**

**요소 노드는 HTML 요소를 표현한다.** **HTML 요소는 중첩에 의해 부자 관계**를 가지며 이 부자 관계를 통해 정보를 구조화한다. 따라서 요소 노드는 문서의 구조를 서술한다고 말 할 수 있다. **어트리뷰트, 텍스트 노드에 접근하려면 먼저 요소 노드를 찾아 접근해야 한다.** **모든 요소 노드는** 요소별 특성을 표현하기 위해 **HTMLElement 객체를 상속한 객체로 구성**된다. (그림: DOM tree의 객체 구성 참고)

**어트리뷰트 노드(Attribute Node)**

어트리뷰트 노드는 **HTML 요소의 어트리뷰트를 표현**한다. 어트리뷰트 노드는 **해당 어트리뷰트가 지정된 요소의 자식이 아니라 해당 요소의 일부로 표현**된다. 따라서 해당 요소 노드를 찾아 접근하면 어트리뷰트를 참조, 수정할 수 있다.

**텍스트 노드(Text Node)**

텍스트 노드는 HTML 요소의 텍스트를 표현한다. **텍스트 노드는 요소 노드의 자식**이며 자신의 자식 노드를 가질 수 없다. 즉, **텍스트 노드는 DOM tree의 최종단**이다.



DOM 트리를 크롬 브라우저에서 확인하려면 개발자 도구의 Elements를 선택한 후 오른쪽의 properties를 선택한다.

![1560089499412](C:\Users\gyuha\AppData\Roaming\Typora\typora-user-images\1560089499412.png)





## DOM Query / Traversing (요소에의 접근)



### 하나의 요소 노드 선택

- document.getElementById(id)
  - id 어트리뷰트 값으로 요소 노드를 한 개 선택한다.
- document.querySelector(cssSelector)
  - CSS 셀렉터를 사용하여 요소 노드를 한 개 선택한다.



### 여러 개의 요소 노드 선택

- document.getElementByClassName(class)
  - class 어트리뷰트 값으로  요소 노드를 모두 선택한다. 공백으로 구분하여 여러 개의 class를 지정할 수 있다.

```javascript
// HTMLCollection을 반환한다. HTMLCollection은 live하다.
const elems = document.getElementsByClassName('red');

for (let i = 0; i < elems.length; i++) {
  // 클래스 어트리뷰트의 값을 변경한다.
  elems[i].className = 'blue';
}
```

위 예제를 실행해보면 예상대로 동작하지 않는다.

#### **원인**

getElementsByClassName 메소드의 반환값은 `HTMLCollection`이다. 이것은 반환값이 복수인 경우, HTMLElement의 리스트를 담아 반환하기 위한 객체로 배열과 비슷한 사용법을 가지고 있지만 배열은 아닌 **유사배열(array-like object)**이다. 또한 HTMLCollection은 **실시간으로 Node의 상태 변경을 반영한다.** (live HTMLCollection) 

즉, className을 `blue`로 변경한 요소들은  `document.getElementsByClassName('red');` 로 선택한 선택 조건의 맞지 않으므로 실시간으로 제외된다.



### 해결책

1. 유사 배열 객체인 HTMLCollection을 배열로 변경한다.
2. `querySelectorAll` 메소드를 사용하여 HTMLCollection(live)이 아닌 NodeList(non-live)를 반환하게 한다.