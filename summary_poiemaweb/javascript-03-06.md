# 3. 자바스크립트 개발 환경과 실행 방법



## 1. 자바스크립트 실행 환경

자바스크립트는 브라우저와 Node.js 환경에서 실행할 수 있다.

- 브라우저와 Node.js의 존재목적과 그에 따른 차이점

  - 브라우저의 존재목적

    - 웹페이지를 화면에 렌더링

      

  - Node.js의 존재목적

    - 서버 개발환경을 제공하는 것

  

  - 브라우저와 Node.js의 차이점
    -  브라우저는 HTML 요소를 선택하거나 조작하는 기능들의 집합인 DOM API를 기본적으로 제공한다. **반면에,** 서버에서는 HTML 문서의 HTML 요소를 객체화한 DOM(Document Object Model)을 다룰 일이 없기 때문에 Node.js는 클라이언트 사이드 Web API인 DOM API를 제공하지 않는다.	 
    -  Node.js에서는 파일을 생성하고 수정할 수 있는 File 시스템을 기본 제공하지만 브라우저는 이를 지원하지 않는다.  브라우저는 사용자 컴퓨터에서 동작하기 때문에 보안상의 이유로 이를 금지하고 있다.
    - 브라우저는 ECMAScript와 [클라이언트 사이드 Web API](https://www.w3.org/standards/webdesign/script)를 지원하고 Node.js는 ECMAScript와  [Node.js 고유의 API](https://nodejs.org/dist/latest-v12.x/docs/api/)를 지원한다.

<br>

## 2. 웹 브라우저

### 웹 브라우저는 어떻게 동작하는가?

- 웹 애플리케이션의 자바스크립트는 브라우저에서 HTML, CSS와 함께 실행된다.

- 브라우저의 핵심 기능은 사용자가 참조하고자 하는 웹 페이지를 서버에 **요청(Request)**하고 서버의 **응답(Response)**을 받아 브라우저에 표시하는 것이다.

- HTML, CSS 파일은 렌더링 엔진의 HTML 파서와 CSS 파서에 의해 **파싱(Parsing)**되어 DOM, CSSOM 트리로 변환되고 **렌더 트리로 결합**된다. 이렇게 생성된 렌더 트리를 기반으로 브라우저는 웹 페이지를 표시한다.

- 브라우저는 **동기(Synchronous)적**으로 HTML, CSS, 자바스크립트를 처리한다. 이것은 **script 태그의 위치**에 따라 블로킹이 발생하여 DOM의 생성이 지연될 수 있다는 것을 의미한다. 따라서 **script 태그의 위치는 중요한 의미를 갖는다. **

  <br>

- script 태그의 위치에 따른 DOM 객체
  - **head 요소 내부에 script 태그를 위치**시키면 HTML 요소가 파싱되어 **DOM 객체로 변환되기 이전**에 자바스크립트가 실행되기 때문에 아직 변환되지 않은 HTML요소를 참조할 수 없다.
  - 반면에, body 요소의 가장 아래에 script 태그를 위치시키면 **이미 HTML 파서가 HTML 요소를 모두 파싱하여 DOM 객체를 생성**하였기 때문에 자바스크립트가 **DOM 조작 시 에러가 발생하지 않는다.** 또한, HTML 요소들이 스크립트 로딩 지연으로 인해 렌더링에 지장 받는 일이 발생하지 않아 **페이지 로딩 시간이 단축**된다.

- 질문사항

  1. 브라우저는 왜 동기적으로 HTML, CSS, 자바스크립트를 처리하는 것일까?  비동기적으로 처리하면 안되는 것인가?   동기적으로 처리하는 것의 장점이 무엇일까? 

  2. body 요소의 가장 아래에 script 태그를 위치는 것이 완벽한 해결 방법일까? 단점은 없을까?

     <br>

## 3. Node.js

### Node.js와 npm 소개

- Node.js

  - Chrome V8 자바스크립트 엔진으로 빌드된 자바스크립트 [런타임 환경(Runtime Environment)](https://ko.wikipedia.org/wiki/%EB%9F%B0%ED%83%80%EC%9E%84)

  - 브라우저 이외의 환경에서 동작시킬 수 있는 자바스크립트 실행 환경
  - 서버 사이드 애플리케이션 개발에 사용
  - 데이터를 실시간 처리하여 빈번한 I/O가 발생하는 SPA(Single Page Application)에 적합
  - 프런트엔드 영역의 다양한 도구나 라이브러리도 Node.js 환경에서 동작

- npm
  - 자바스크립트 패키지 매니저
  - Node.js에서 사용할 수 있는 **모듈들을 패키지화**하여 모아둔 **저장소** 역할
  - 패키지 설치 및 관리를 위한 CLI(Command line interface)를 제공



- 질문사항
  - 데이터를 실시간 처리하여 빈번한 I/O가 발생하는 SPA에 구체적인 예시는 무엇이 있을까??? 예상) SNS의 댓글

<br>





# 4. 변수



## 1. 변수란 무엇인가? 왜 필요한가?

### 변수

- **하나의 값**을 저장할 수 있는 **메모리 공간에 붙인 이름** 또는 **메모리 공간 자체**를 말한다.

- **메모리 주소를 직접 다루지 않아도** 값을 저장하거나 참조할 수 있다
-  재사용할 수 있도록 **메모리 공간을 식별**할 수 있는 이름을 붙인 것
-  변수명을 통해 컴퓨터에게 **참조를 요청**하면 컴퓨터는 **변수명과 매핑된 메모리 주소**를 통해 메모리 공간에 접근하여 저장된 값을 반환해 준다.
- 변수에 값을 저장하는 것을 **할당(assignment 대입, 저장)**이라 하고, 변수에 저장된 값을 읽어 들이는 것을 **참조(reference)**라고 한다.
- 변수는 사람의 언어로 기술한 변수명을 통해 저장된 값의 의미를 명확히 할 수 있다. --> **가독성**을 높여준다. 

- 질문사항
  - 메모리 주소로 메모리에 직접 접근하는 것이 위험한 일이지만 재사용은 가능한 것 아닌가? 
  - 그렇다면 변수는 개발자가 직접적으로 메모리를 제어하는 것이 위험하기 때문에 간접적인 제어가 가능하도록 고안된 것인가???

### 식별자 

- 변수명을 식별자라고도 부른다. 
- 어떤 값을 구별하여 식별해낼 수 있는 고유한 이름을 말한다.
-  **식별자라는 용어는 변수에만 국한해서 사용하지 않는다.** 예를 들어, 변수, 함수, 클래스 등의 이름은 값을 구별할 수 있는 이름이므로 모두 식별자다. 따라서 **식별자는 변수명보다는 상위 개념**이다.



## 2. 변수 선언

### 변수 선언 이란?

- **변수 선언(Variable declaration)이란 변수명(식별자)을 등록하여 자바스크립트 엔진에 변수의 존재를 알려 관리하도록 하는 것을 말한다**
- 변수를 선언할 때는 var, let, const 키워드를 사용한다.
- let, const 키워드가 도입되기 이전까지 변수를 선언할 수 있는 유일한 키워드인 **var**은 블록 레벨 스코프(Block-level scope)를 지원하지 않는 점, 중복 선언을 허용하는 점, var 키워드 없이 변수 선언이 가능하다는 단점이 있다.
- 변수의 값을 할당하지 않으면 메모리 공간이 비어있는 것이 아니라 자바스크립트 엔진에 의해 `undefined`(원시타입의 값)라는 값이 암묵적으로 할당되어 초기화된다. 

### 자바스크립트 엔진의 변수 선언 2단계

1. 선언 단계(Declaration phase)

   - 변수명을 등록하여 자바스크립트 엔진에 변수의 존재를 알린다.

     

2. 초기화 단계(Initialization phase)

   - 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 `undefined`를 할당한다.





## 3. 변수 선언의 실행 시점과 변수 호이스팅

### 변수 선언의 실행 시점

- 변수 선언은 소스 코드가 순차적으로 한줄씩 **실행되는 시점(런타임, run-time)**이 아니라 그 **이전(파싱 타임, parsing-time)**에 먼저 실행된다
- 자바스크립트 엔진은 소스 코드를 **한줄씩 순차적으로 실행하기 이전에 먼저 소스 코드 전체를 평가**한다. 이때 모든 선언문(변수 선언문, 함수 선언문 등)을 찾아내어 **식별자를 등록하고 초기화**한다. 그후, 선언문을 제외한 소스 코드를 한줄씩 순차적으로 실행한다.





### 변수 호이스팅(Variable Hoisting)

- 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징
- 호이스팅은 변수 선언 뿐만이 아니라 var, let, const, function, function*, class 키워드를 사용한 모든 선언문에 적용된다.



- 질문사항 

  - let , const 키워드를 사용하여 변수를 선언하면 마치 호이스팅이 되지 않은 것처럼 `ReferenceError`(참조에러)가 발생하는데 왜 그런 것인지?????



## 4. 값의 할당

- 변수에 값을 할당(assignment 대입, 저장)할 때는 할당 연산자(=)를 사용한다.
- **변수 선언은 다른 코드가 실행되기 이전, 즉 파싱 타임에 먼저 실행되지만 값의 할당은 코드가 순차적으로 실행되는 시점인 런타임에 실행된다.**
- 따라서, 변수의 호이스팅이 일어나도 값이 할당된 상태가 아닌 선언된 상태로 호이스팅된다.
- 변수에 값을 할당할 때는 이전 값 `undefined`가 저장되어 있던 메모리 공간을 지우고 그 메모리 공간에 할당 값을 새롭게 저장하는 것이 아니라 **새로운 메모리 공간을 확보하고 그 메모리 공간에 할당 값을 저장하는 것에 주의하자.**

- 질문사항 
  - 변수의 초기화는 필수적인 사항?????
  - 선언과 동시에 자동적으로 초기화 되는 것인가????
    - --> var 키워드는 그렇다.



## 5. 값의 재할당

- 현재 변수가 저장하고 있는 값을 버리고 새로운 값을 저장하는 것
- 처음 값을 할당했을 때와 마찬가지로 **새로운 메모리 공간을 확보**하고 그 메모리 공간에 값을 저장
- 변수에 값이 새롭게 재할당되면 **이전에 할당된 값**은 어떤 변수도 값으로 갖고 있지 않은 **불필요한 값**이 된라. 이러한 값은 `가비지 컬렉터(Garbage Collector)`에 의해 메모리에서 자동 해제된다.
- 자바스크립트와 같은 **매니지드 언어**는 메모리의 할당 및 해제를 위한 메모리 관리 기능을 언어 차원에서 담당하고 **개발자의 직접적인 메모리 제어를 허용하지 않는다.** 



### 6. 식별자 네이밍 규칙

- 어떤 데이터를 식별해낼 수 있는 고유한 이름

- 특수문자를 제외한 문자, 숫자, underscore( _ ), 달러 기호($)를 포함할 수 있다.
- 숫자로 시작하는 것은 허용하지 않는다.
- 예약어는 식별자로 사용할 수 없다.
- 자바스크립트는 대소문자를 구별한다.
- 가장 일반적인 것은 변수와 함수의 이름에는 카멜 케이스를 사용하고 생성자 함수, 클래스의 이름에는 파스칼 케이스를 사용하는 것



# 5. 데이터 타입



## 1. 데이터 타입이란 무엇인가? 왜 필요한가?



### 1.1. 데이터 타입에 의한 메모리 공간의 확보

- 값의 종류에 따라 확보해야 할 메모리의 크기가 다르기 때문에 값을 저장하기 위해서는 먼저 확보해야 할 메모리의 크기를 알아야 한다. 

  

### 1.2 데이터 타입에 의한 값의 해석

- 데이터 타입(Data Type)은 값의 종류를 말한다. 자바스크립트의 모든 값은 데이터 타입을 갖는다. 

- 컴퓨터는 숫자, 텍스트, 이미지, 동영상 등의 **모든 데이터를 2진수로 처리**한다. **예를 들어** 2진수 `0100 0001`를 숫자로 해석하면 65이지만 문자로 해석하면 `‘A’`이다.
- 컴퓨터는 메모리 공간의 주소에서 읽어 들인 2진수를 각각의 데이터 타입으로 인식하고 해석한다.



### 핵심 요약(데이터 타입이 필요한 이유)

- 값을 저장할 때 확보해야 하는 **메모리 공간의 크기**를 결정하기 위해
- 값을 참조할 때 한번에 읽어 들여야 할 **메모리 공간의 크기**를 결정하기 위해
- 메모리에서 읽어 들인 **2진수를 어떻게 해석**할 지를 결정하기 위해



## 2. 값(value)

- **더 이상 평가할 수 없는** 하나의 표현식

- 표현식은 값을 생성하는 문이다. ---> ex) 10 +20

- 변수(Variable)는 **하나 값**을 저장할 수 있는 메모리 공간에 붙인 이름 또는 메모리 공간 자체를 말한다고 했다. 따라서 값은 변수에 할당할 수 있다.

```javascript
  // 변수에는 표현식 10 + 20의 평가되어 생성한 값 30이 할당된다.
  var sum = 10 + 20;
```

  

## 3. 값의 생성



### 3.1 리터럴

- **리터럴(literal)은 소스코드 안에서 직접 만들어 낸 고정된 값 자체를 말한다.** 



#### 3.1.1 리터럴 표기법을 통한 값의 생성

- 리터럴 표기법은 값을 생성하는 방법이다.

- 리터럴 표기법은 자바스크립트 엔진과 개발자 간의 약속으로 이해할 수 있다.



#### 3.1.2 값과 리터럴의 관계

- 리터럴은 값의 최소 단위이다.

- 리터럴은 그 자체로 값이 될 수 있지만 모든 값이 리터럴인 것은 아니다.



### 3.2. 표현식

- **하나의 값으로 평가될 수 있는 문(statement)이다.**

- 값을 만드는 방법
- 리터럴, 식별자(변수명, 함수명 등), 연산자, 함수 호출 등의 조합



## 4. 데이터 타입의 분류

- 자바스크립트(ES6)는 7개의 데이터 타입을 제공한다. 
- 7개의 데이터 타입은 원시 타입(primitive type)과 객체 타입(object/reference type)으로 분류할 수 있다.
- 원시 타입(primitive type)
  - 숫자(number) 타입: 숫자 (정수, 실수)
  - 문자열(string) 타입: 문자열
  - 불리언(boolean) 타입: 논리적 참과 거짓
  - undefined 타입:	선언은 되었지만 값을 할당하지 않은 변수에 암묵적으로 할당되는 값
  - null 타입: 값이 없다는 것을 의도적으로 명시할 때 사용하는 값
  - Symbol 타입: ES6에서 새롭게 추가된 7번째 타입
- 객체 타입 (object/reference type): 객체, 함수, 배열 등





## 5. 숫자 타입

- 자바스크립트는 독특하게 하나의 숫자 타입만 존재한다.

- ECMAScript 사양에 따르면 숫자 타입의 값은 배정밀도 64비트 부동소수점 형식([double-precision 64-bit floating-point format](https://en.wikipedia.org/wiki/Double-precision_floating-point_format) : -(253 -1) ~ 253 -1 사이의 숫자 값)을 따른다. **즉, 모든 수를 실수로 처리하며 정수만을 표현하기 위한 특별한 데이터 타입(integer type)은 없다.**
- 따라서 정수로 표시되는 수 끼리 나누더라도 실수가 나올 수 있다.
- 숫자 타입은 추가적으로 3가지 특별한 값들도 표현할 수 있다.
  - Infinity : 양의 무한대
  - -Infinity : 음의 무한대
  - NaN : 산술 연산 불가(not-a-number)





## 6. 문자열 타입

- 문자열은 0개 이상의 16bit 유니코드 문자(UTF-16) 들의 집합으로 대부분의 전세계의 문자를 표현할 수 있다.
- 일반적으로 작은 따옴표를 사용하여 표기한다.
- 자바스크립트의 문자열은 원시 타입이며 변경 불가능한 값 (immutable value)다.



### 6.1. 템플릿 리터럴

- 템플릿 리터럴은 일반 문자열과 비슷해 보이지만, ‘ 또는 “ 같은 통상적인 따옴표 문자 대신 백틱(backtick) 문자 `를 사용한다.

- ES6 템플릿 리터럴은 일반적인 문자열과 달리 여러 줄에 걸쳐 문자열을 작성할 수 있으며 템플릿 리터럴 내의 모든 공백은 있는 그대로 적용된다.

- 문자열 인터폴레이션은 ${ … }으로 표현식을 감싼다. 문자열 인터폴레이션 내의 표현식은 문자열로 강제 타입 변환된다.



## 7. 불리언 타입

- 불리언 타입의 값은 참과 거짓으로 구분되는 조건에 의해 프로그램의 흐름을 제어하는 조건문에서 자주 사용





## 8. undefined 타입

- undefined 타입의 값은 undefined가 유일하다.
- 선언 이후 명시적으로 값을 할당하지 않은 변수는 undefined 값을 가진다.
- 변수에 값이 없다는 것을 명시하고 싶은 경우에는 undefined를 할당하는 것이 아니라 null을 할당한다.
- undefined를 한국어로 직역하면 “정의되지 않은”이다. 여기서 정의란 변수에 값이 할당되어 변수의 실체를 명확히 하는 것을 말한다.
- 자바스크립트의 변수는 선언과 동시에 undefined로 정의되므로 선언과 정의의 구분이 모호



## 9. null 타입

- null 타입의 값은 null이 유일하다.
- null은 변수에 값이 없다는 것을 의도적으로 명시 할 때 사용한다.
-  변수가 이전에 참조하던 값을 더이상 참조하지 않겠다는 의미를 가진다(사용을 권장하지 않는다.)
- 함수가 유효한 값을 반환할 수 없는 경우, 명시적으로 null을 반환하기도 한다. 



## 10. symbol 타입

- ES6에서 새롭게 추가된 7번째 타입으로 변경 불가능한 원시 타입의 값이다. 
- 주로 이름의 충돌 위험이 없는 객체의 유일한 프로퍼티 키(property key)를 만들기 위해 사용한다.



## 11. 객체 타입

- 자바스크립트는 객체 기반의 언어이며 자바스크립트를 이루고 있는 거의 “모든 것”이 객체이다.



## 12. 동적 타이핑



### 12.1. 동적 타입 언어와 정적 타입 언어

- 자바스크립트는 정적 타입 언어와는 다르게 변수를 선언할 때 타입을 선언하지 않는다. 다만 var, let, const 키워드를 사용해 변수를 선언할 뿐이다.

- 자바스크립트는 값을 할당하는 시점에 변수의 타입이 동적으로 결정되고 변수의 타입을 언제든지 자유롭게 변경할 수 있다.
- **자바스크립트 변수는 선언이 아닌 할당에 의해 타입이 결정된다. 그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다**



### 12.2. 동적 타입 언어와 변수

#### 동적 타입 언어의 구조적 단점

- 복잡한 프로그램에서는 동적으로 변화하는 데이터 타입을 추적하기 어려울 수 있다. 
- 변수가 저장하고 있는 값을 확인하기 전에는 값의 타입을 확신할 수 없다.
-  개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다.
-  유연성(flexibility)은 높지만, 신뢰성(reliability)은 떨어진다.



#### 변수를 사용 할 때 주의할 사항

- 변수의 사용을 적극적으로 줄인다. 변수의 개수가 많으면 많을수록 오류가 발생할 확률은 높아진다.
- 전역 변수는 사용하지 않는다. 변수의 생명주기를 최대한 짧게 만든다.
- 변수보다는 상수를 사용해 값의 변경을 억제한다.
- 변수명은 변수의 존재 이유를 파악할 수 있도록 명명한다.





# 6. 연산자

## 1. 표현식과 연산자

#### 표현식

- 하나의 값으로 평가될 수 있는 문
- 표현식은 평가되어 결국 하나의 값이 되므로 표현식과 표현식이 평가되어 생성된 값은 동등한 관계, 즉 동치(Equivalent)다
- 표현식은 값처럼 사용할 수 있다. --> 값이 위치할 수 있는 자리에는 표현식도 위치할 수 있다는 것을 의미



## 2. 문과 표현식

- 문(statement)은 하나 이상의 표현식과 키워드의 조합으로 **자바스크립트 엔진에게 내리는 명령**이다
- **자바스크립트의 모든 코드는 문 또는 표현식이다.** 
- `문` --> 마침표로 끝나는 하나의 완전한 문장, 표현식 --> 문을 구성하는 `구`와 같은 요소
- 표현식은 그 자체로 문이 될 수도 있다. 하지만 문이 표현식이 될 수는 없다.
- **표현식의 역할은 값을 생성하는 것이다. 문의 역할은 표현식으로 생성한 값을 사용해 자바스크립트 엔진에게 명령을 내리는 것이다.**
- **문에는 표현식인 문과 표현식이 아닌 문이 있다.**
- **표현식인 문과 표현식이 아닌 문을 구별하기 위한 가장 간단하고 명료한 방법은 변수에 할당해 보는 것이다.**



## 3. 연산자란?

- 연산자(Operator)는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입 연산(operation) 등을 수행해 하나의 값을 만든다.
- 피연산자는 연산의 대상이 되어야 하므로 값으로 평가할 수 있어야 한다. 
-  연산자는 값으로 평가된 피연산자를 연산해 새로운 값을 만든다.



## 4. 산술 연산자

- 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만든다. 
- 산술 연산이 불가능한 경우, NaN을 반환한다.



### 4.1. 이항 산술 연산자

- 2개의 피연산자를 산술 연산하여 숫자 타입의 값을 만든다.
- 모든 이항 산술 연산자는 피연산자의 값을 변경하는 부수 효과(Side effect)가 없다. 언제나 새로운 값을 만들 뿐이다.



### 4.2. 단항 산술 연산자

- 1개의 피연산자를 산술 연산하여 숫자 타입의 값을 만든다. 
- 이항 산술 연산자와는 달리 **증가/감소(++/–) 연산자는 피연산자의 값을 변경하는 부수 효과가 있다.**
- 증가/감소(++/–) 연산자는 위치에 의미가 있다.
  - 피연산자 `앞`에 위치한 전위 증가/감소 연산자(Prefix increment/decrement operator)는 먼저 피연산자의 값을 증가/감소시킨 후, 다른 연산을 수행한다.
  - 피연산자 `뒤`에 위치한 후위 증가/감소 연산자(Postfix increment/decrement operator)는 먼저 다른 연산을 수행한 후, 피연산자의 값을 증가/감소시킨다.

- `+`단항 연산자는 숫자 타입이 아닌 피연산자에 사용하면 피연산자를 숫자 타입으로 변환하여 반환한다. 

- `–` 단항 연산자는 피연산자의 부호를 반전한 값을 반환한다.



### 4.3. 문자열 연결 연산자

- **`+`연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다.** 
- 개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다. 이를 **암묵적 타입 변환(Implicit coercion) 또는 타입 강제 변환(Type coercion)**이라고 한다.





## 5. 할당 연산자

- 할당 연산은 하나의 값으로 평가되는 표현식이다.
- 할당 연산 표현식을 다른 변수에 할당할 수도 있다. 이러한 특징을 활용해 여러 변수에 동일한 값을 연쇄 할당할 수 있다.





## 6. 비교 연산자

- 비교 연산자(Comparison Operator)는 좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값을 반환한다.



### 6.1. 동등 / 일치 비교 연산자

- 동등 비교(==) 연산자는 좌항과 우항의 피연산자를 비교할 때 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값을 갖는지 비교한다.
- 동등 비교(==) 연산자는 편리한 경우도 있지만 결과를 예측하기 어렵기 때문에 부작용을 일으킬 수 있으므로 사용하지 않는 편이 좋다.
- 일치 비교(===) 연산자는 좌항과 우항의 피연산자가 타입도 같고 값도 같은 경우에 한하여 true를 반환한다. 
- NaN은 자신과 일치하지 않는 유일한 값이기 때문에 일치 비교 연산자에서 주의해야 한다.
- 숫자 0도 주의하도록 하자. 자바스크립트에는 `양의 0`과 `음의 0`이 있는데 이들을 비교하면 true를 반환한다.



### 6.2. 대소 관계 비교 연산자

- 대소 관계 비교 연산자는 피연산자의 크기를 비교하여 불리언 값을 반환한다.



## 7. 삼항 조건 연산자

- 자바스크립트의 유일한 삼항 연산자

- 삼항 조건 연산자 표현식

  ```
  조건식 ? 조건식이 ture일때 반환할 값 : 조건식이 false일때 반환할 값
  ```

  

- 삼항 조건 연산자 표현식은 값으로 평가할 수 있는 표현식인 문이다. 따라서 삼항 조건 연산자식은 다른 표현식의 일부가 될 수 있어 매우 유용하다.





## 8. 논리 연산자

- 피연산자는 반드시 불리언 값일 필요는 없다

- 만약 피연산자가 불리언 값이 아니면 불리언 타입으로 암묵적 타입 변환된다.